# TIKITAKA | 이벤트 프로모션 페이지

🔗 https://tikitaka-event.vercel.app/
> "신규 서비스 오픈 기념 이벤트! 응모하고 특별 혜택을 받아가세요"

가상의 메신저 서비스 **TIKITAKA**를 구상하고, 이를 기반으로 **신규 서비스 오픈 기념 이벤트 프로모션 페이지**를 제작했습니다.

<br>

## 주요 기능
- 실시간 카운트다운 타이머
- 이벤트 응모 폼 (유효성 검사, URL 공유, 중복 응모 방지)
- 행운의 룰렛 게임
- GSAP 스크롤 애니메이션
- 반응형 디자인

### 구현 시 고민한 점

#### 1. 카운트다운 타이머 API 호출 최적화
카운트다운 타이머 구현 초기에는 setInterval로 1초마다 실행되는 함수 내부에서 이벤트 정보를 가져오는 GET API를 호출했습니다. 이로 인해 1초마다 불필요한 API 호출이 발생했습니다.
이를 개선하기 위해 onMounted에서 initCountDown 함수를 한 번만 호출하여 서버에서 endTime을 가져와 변수에 저장했습니다. 이후 countDownTimer 함수는 저장된 endTime과 현재 시간을 비교하여 로컬에서만 계산하도록 변경했습니다. 
이렇게 하면 API 호출은 초기 1회만 발생하고, 이후에는 클라이언트 측 시간 계산만 수행합니다.

#### 2. 날짜 파싱 호환성 문제
카운트다운 타이머 구현 시 endTime을 new Date()로 파싱하는 과정에서 모바일 브라우저에서 NaN 오류가 발생했습니다.
데스크톱에서는 "2026.01.07 23:59:59" 형식이 정상적으로 파싱되었지만, 모바일 브라우저는 ISO 8601 형식(YYYY-MM-DDTHH:mm:ss)을 선호했습니다.
이를 해결하기 위해 날짜 형식을 변환하는 로직을 추가하여 모든 브라우저에서 정상적으로 작동하도록 개선했습니다.

#### 3. 전화번호 입력 UX 개선
전화번호 유효성 검사에서 하이픈을 필수로 입력해야 통과하도록 구현했지만, 모바일 환경에서 하이픈 입력이 어려웠습니다.
이를 개선하기 위해 숫자만 입력해도 자동으로 하이픈이 추가되어 010-1234-5678 형식으로 변환되도록 구현했습니다. 
정규식을 사용해 숫자만 추출하고, 입력 길이에 따라 하이픈을 자동으로 추가하는 로직으로 변경했습니다.

#### 4. 룰렛 원형 그라데이션 구현
룰렛을 구현할 때 초기에는 다른 방식으로 시도했지만, 원형 안에 6개의 항목이 정확한 각도로 배치되지 않는 문제가 발생했습니다.
각 항목이 균등한 각도(360° / 6 = 60°)로 배치되어야 하는데, 기존 방식으로는 각도 계산이 정확하지 않았습니다.
이를 해결하기 위해 CSS conic-gradient를 사용하여 각 항목의 시작 각도와 끝 각도를 정확히 계산하고, anglePerItem(360° / 룰렛 항목 개수)을 통해 균등하게 분할하도록 구현했습니다.
각 항목의 시작 각도(startAngle)와 끝 각도(endAngle)를 동적으로 계산하여 conic-gradient 문자열을 생성함으로써, 6개의 항목이 정확히 60도씩 배치되도록 개선했습니다.

<br>

## 기술 스택

| 분류	| 기술 |
| --- | --- |
| **Frontend** | Vue 3, TypeScript, Vite, GSAP, Axios, vue3-toastify |
| **Backend** | JSON Server |
| **Hosting** | Railway (Backend), Vercel (Frontend) |

### 사용한 라이브러리 및 선택 이유

- **Axios**: fetch API와 달리 Axios는 HTTP 오류(4xx, 5xx)를 에러로 분리해 처리할 수 있어 에러 핸들링 로직을 단순화할 수 있습니다. 또한 인터셉터를 통해 공통 에러 처리와 요청 설정을 중앙에서 관리할 수 있어 유지보수 측면에서 유리하다고 판단해 선택했습니다.
- **GSAP**: CSS 애니메이션만으로는 스크롤 위치에 따라 정확하게 애니메이션을 제어하는 데 한계가 있었습니다. GSAP의 ScrollTrigger를 사용하면 스크롤 위치를 기준으로 애니메이션을 세밀하게 제어할 수 있고, 하드웨어 가속을 활용해 보다 부드러운 인터랙션을 구현할 수 있어 선택했습니다.
- **vue3-toastify**: 초기에는 vue-toastification을 고려했지만 Vue 3와의 호환성 이슈가 있었습니다. vue3-toastify는 Vue 3를 공식적으로 지원하며 사용 방법이 간단하고 커스터마이징도 쉬워, 사용자 피드백을 위한 토스트 메시지 구현에 적합하다고 판단해 선택했습니다.
- **JSON Server**: 외부 Mock API 서비스(JSONPlaceholder, MockAPI.io)도 고려했지만, 로컬에서 db.json 파일을 직접 관리할 수 있는 JSON Server를 선택했습니다. 데이터 구조를 Git으로 함께 관리할 수 있고, 외부 서비스에 의존하지 않아 오프라인 환경에서도 개발이 가능하다는 점이 장점이었습니다. 또한 배포 환경에서도 동일한 데이터 구조로 쉽게 전환할 수 있어 프로젝트에 적합하다고 판단했습니다.

<br>

## 프로젝트 구조

```
event/
├── server/               # 백엔드 (JSON Server)
│   ├── server.js         # 서버 실행 파일
│   ├── db.json           # Mock 데이터
│   └── package.json      # 서버 의존성
├── src/                  # 프론트엔드
│   ├── api/              # API 관련
│   ├── components/       # Vue 컴포넌트
│   └── utils/            # 유틸리티 함수
└── package.json          # 프론트엔드 의존성
```

<br>

## 실행 방법

#### 1. 의존성 설치
```bash
npm install
```

#### 2. 환경변수 설정
- 프로젝트 루트에 .env 파일을 생성하고 다음 내용을 추가하세요:
```bash
VITE_API_URL=http://localhost:3000
```

#### 3. 백엔드 서버 실행
- 터미널 1에서:
```bash
npm run json-server
```

#### 4. 프론트엔드 서버 실행
- 터미널 2에서:
```bash
npm run dev
```
